
// ===============================================
/// [2d/3d]
alias Vec2_i CellCoord;
alias Vec2_i GridSize;

// ===============================================
/// Grid interface.
interface IGrid
{
	/// Get the grid size.
	GridSize getGridSize();
	/// Get the coordinate of the cell that contains pos.
	CellCoord getCellCoord(Point pos);
	/// Returns true if there's a cell allocated in the given coordinate exists.
	Boolean isValidCellCoord(CellCoord coord);
	/// Get cell value.
	UInt32 getCellValue(CellCoord coord);
	/// Set cell value.
	setCellValue!(CellCoord coord, UInt32 newVal);
};

// ===============================================
/// Simple packed rectangular grid that implements IGrid.
object SimpleGrid : IGrid
{
	private UInt32 cells[];
	private GridSize gridSize;
	private Point origin;
};

function SimpleGrid(GridSize gridSize, Point origin)
{
	this.gridSize = gridSize;
	this.origin = origin;
	this.cells.resize(gridSize.x * gridSize.y);
	for(UInt32 i = 0; i < gridSize.x * gridSize.y; ++i)
	{
		this.cells[i] = UInt32Max;
	}
}

function GridSize SimpleGrid.getGridSize()
{
	return this.gridSize;	
}

private function Index SimpleGrid.cellToIndex(CellCoord coord)
{
	// [2d/3d]
	//return
	//	coord.z * this.gridSize.x * this.gridSize.y +
	//	coord.y * this.gridSize.x +
	//	coord.x;
	return coord.y * this.gridSize.x + coord.x;

}

function CellCoord SimpleGrid.getCellCoord(Point pos)
{
	// [2d/3d]
	//return CellCoord(pos.x - this.origin.x, pos.y - this.origin.y, pos.z - this.origin.z);
	return CellCoord(pos.x - this.origin.x, pos.y - this.origin.y);
}

function Boolean SimpleGrid.isValidCellCoord(CellCoord coord)
{
	// [2d/3d]
	//return coord.x >= 0 && coord.y >= 0 && coord.z >= 0 && coord.x < this.gridSize.x && coord.y < this.gridSize.y && coord.z < this.gridSize.z;
	return coord.x >= 0 && coord.y >= 0 && coord.x < this.gridSize.x && coord.y < this.gridSize.y;
}

// NOTE: A cell value contains an array index where the point coordinate is
// NOTE: When a thread creates a point, it
// NOTE: 	a) Stores the point coordinate to the points[] array.
// NOTE: 	b) Updates the cell value the point is in to tell every thread the existence of the point
// NOTE:       and access the right index in the points[] array.
// NOTE: so for the other thread to work properly the order of b) cannot be visible before a) in other threads.
// NOTE: In C++ it can be done with std::atomic. Fabric Engine KL has some sopport functions,
// NOTE: atomicMemoryBarrier() family but I couldn't find std::atomic::store(), std::atomic::load()
// NOTE: equivalent.
// NOTE: I tried to lower the risk of b) getting visible before a) by pre-allocating points[] array
// NOTE: which is making the situation better but still not safe.
// NOTE: Other synchronization functions that I haven't used will do this but it'll be very slow,
// NOTE: and Bridson's poisson disk is not suitable for parallel processing anyway.

function UInt32 SimpleGrid.getCellValue(CellCoord coord)
{
	return this.cells[this.cellToIndex(coord)];
}

function SimpleGrid.setCellValue!(CellCoord coord, UInt32 newVal)
{
	this.cells[this.cellToIndex(coord)] = newVal;
}
