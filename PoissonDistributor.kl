require FabricSynchronization;

// [2d/3d]
const UInt32 DIMENSION = 2;

// ===============================================
/// Utility class to find if neighbor points exist
object GridNeighborFinder
{
	/// Shared result points list. For implementation reason points[0] is not used.
	private Point points[];
	/// Shared grid used to distribute points.
	private IGrid grid;
};

function GridNeighborFinder(Point points[], IGrid grid)
{
	this.points = points;
	this.grid = grid;
}

/// Returns true if neighbor is found.
function Boolean GridNeighborFinder.isNeighborExists(Point searchPoint, Float32 radius, Boolean isExcludeSelfCell)
{
	CellCoord cellCoord = this.grid.getCellCoord(searchPoint);

	//  Search neighbor cells to see if no points exists nearby.
	const UInt32 NUM_NEIGHBORS = 25; // [2d/3d] 125 if 3d
	for(UInt32 j = 0; j < NUM_NEIGHBORS; ++j)
	{
		if(isExcludeSelfCell)
		{
			// [2d/3d]
			//if(j == 62)
			if(j == 12)
			{
				continue;
			}
		}
		// [2d/3d]
		//UInt32 k = j / 25 - 2;
		//UInt32 l = (j % 25) / 5 - 2;
		//UInt32 m = j % 5 - 2;
		//CellCoord crd = cellCoord + CellCoord(k, l, m);
		UInt32 k = j / 5 - 2;
		UInt32 l = j % 5 - 2;
		CellCoord crd = cellCoord + CellCoord(k, l);

		if( ! this.grid.isValidCellCoord(crd))
		{
			continue;
		}

		// We could do some more early out check here by looking at the intersection
		// of the cell and the circle/sphere search area.

		UInt32 cellValue = this.grid.getCellValue(crd);

		if(cellValue)
		{
			if((this.points[cellValue] - searchPoint).lengthSquared() < radius * radius)
			{
				// Found a point within radius, reject this point.
				return true;
			}
		}
	}

	return false;
}

// ===============================================
/// Thread shared data for Poisson disk calculation.
object PoissonDiskData
{
	/// result points list. For implementation reason points[0] is not used.
	Point points[];
	/// Number of created points.
	UInt32 numPoints;
	/// grid used to distribute points.
	IGrid grid;
	/// region to define where to create points.
	IRegion region;
	/// thread lock.
	SimpleLock lock;
};

private function PoissonDiskData.initializePoints!(UInt32 numPexThreads, io UInt32 seed)
{
	// Create the first points for each distributor to start with.

	const UInt32 NUM_ITERATIONS_PER_THREAD = 5;

	Float32 radius = Float32(sqrt(DIMENSION));
	UInt32 maxNumTries = numPexThreads * NUM_ITERATIONS_PER_THREAD;

	XOrShift randGen(seed);
	Point bBoxMin;
	Point bBoxMax;
	this.region.getBoundingBox(bBoxMin, bBoxMax);

	for(UInt32 i = 0; i < maxNumTries; ++i)
	{
		// [2d/3d]
		//Float32 x = randGen.generate(bBoxMin.x, bBoxMax.x);
		//Float32 y = randGen.generate(bBoxMin.y, bBoxMax.y);
		//Float32 z = randGen.generate(bBoxMin.z, bBoxMax.z);
		//Point point(x, y, z);
		Float32 x = randGen.generate(bBoxMin.x, bBoxMax.x);
		Float32 y = randGen.generate(bBoxMin.y, bBoxMax.y);
		Point point(x, y);

		if(this.region.isInside(point))
		{
			UInt32 j;
			for(j = 1; j < this.numPoints + 1; ++j)
			{
				if((point - this.points[j]).lengthSquared() < radius * radius)
				{
					break;
				}
			}

			if(j == this.numPoints + 1)
			{
				++this.numPoints;
				this.points[this.numPoints] = point;
				this.grid.setCellValue(this.grid.getCellCoord(point), this.numPoints);
			}

			if(this.numPoints == numPexThreads)
			{
				return;
			}
		}
	}
}

function PoissonDiskData(UInt32 numPexThreads, io Point points[], IRegion region, io UInt32 seed)
{
	this.lock = SimpleLock();
	this.points = points;
	this.region = region;

	// Initialize grid.
	Point bBoxMin;
	Point bBoxMax;
	this.region.getBoundingBox(bBoxMin, bBoxMax);

	Float32 EPS = 1.0E-5;

	// [2d/3d]
	//GridSize gridSize(bBoxMax.x - bBoxMin.x + EPS * 2, bBoxMax.y - bBoxMin.y + EPS * 2, bBoxMax.z - bBoxMin.z + EPS * 2);
	//Point origin = bBoxMin - Vec3(EPS, EPS, EPS);
	GridSize gridSize(bBoxMax.x - bBoxMin.x + EPS * 2 + 1, bBoxMax.y - bBoxMin.y + EPS * 2 + 1);
	Point origin = bBoxMin - Vec2(EPS, EPS);

	this.grid = SimpleGrid(gridSize, origin);	

	this.initializePoints(numPexThreads, seed);
}

// ===============================================
/// Bridson's Poisson disk implementation.
object PoissonDiskDistributor
{
	private PoissonDiskData pData;

	/// Per thread active list.
	private ActiveList activeList;
	/// Per thread random generator.
	private XOrShift randGen;
};

function PoissonDiskDistributor(io UInt32 seed, PoissonDiskData pData)
{
	this.pData = pData;
	this.activeList = ActiveList(seed);
	this.randGen = XOrShift(seed);
}

function PoissonDiskDistributor.run!(Point startPoint)
{
	const UInt32 NUM_ITERATIONS = 30;

	// Running this function in parallel can create wrong points,
	// ie. a point that has neighbor points within the radius.
	// We first ignore them and remove those points later.

	// We chose the grid cell edge length to be the unit of length, ie. 1.0 for efficiency.
	// The disk radius must be sqrt(2.0) and sqrt(3.0) in 2d and 3d cases
	// respectively (See Bridson's paper for more details).
	// Every value which has length unit must be scaled accordingly in advance.

	// NOTE: This is for efficiency (and making the program easier as a hidden purpose).
	// NOTE: I wouldn't do that in a real programming unless critical speed is required
	// NOTE: because it makes debugging and maintenance more difficult.

	Float32 radius = Float32(sqrt(DIMENSION));
	GridNeighborFinder gnFinder(this.pData.points, this.pData.grid);

	this.activeList.push(startPoint);

	Index activeListIndex = 0;
	Point currentPoint = startPoint;

	while(activeListIndex != UInt32Max) // While active list is not empty.
	{
		UInt32 i;
		for(i = 0; i < NUM_ITERATIONS; ++i)
		{
			Point searchPoint = currentPoint + this.uniformAnnulusDistribute(radius);

			if( ! this.pData.region.isInside(searchPoint))
			{
				continue;
			}

			CellCoord cellCoord = this.pData.grid.getCellCoord(searchPoint);

			if( ! gnFinder.isNeighborExists(searchPoint, radius, false))
			{
				Index index = UInt32Max;

				// A lock is used to ensure only one point is created in a single cell,
				// also for array push() which is not thread-safe.
				{
					AutoLock(this.pData.lock);
					// Check if no point has been/is being created by another thread.
					if( ! this.pData.grid.getCellValue(cellCoord))
					{
						// We can create a point!
						this.pData.numPoints.atomicInc();
						this.pData.points[this.pData.numPoints] = searchPoint;
						index = this.pData.points.size() - 1;
						this.pData.grid.setCellValue(cellCoord, index);
					}
				}

				if(index != UInt32Max)
				{
					currentPoint = searchPoint;
					this.activeList.push(searchPoint);
					break;
				}

			}
		}

		if(i == NUM_ITERATIONS)
		{
			// Could not create the next point.
			this.activeList.removeElement(activeListIndex);
			currentPoint = this.activeList.getRandom(activeListIndex);
		}
	}
}

private function Point PoissonDiskDistributor.uniformAnnulusDistribute!(Float32 radius)
{
	// [2d/3d]
	Float32 rnd1 = this.randGen.generate01();
	Float32 rnd2 = this.randGen.generate01();
	Float32 r = radius * sqrt(3 * rnd1 + 1);
	Float32 theta = rnd2 * 3.1415926 * 2;
	return Point(r * cos(theta), r * sin(theta));

	// TODO: 3D case.
	// Inverse function	of c = 1/3*(h^3 + H^2 + h)
	//		c: cumulative distribution function
	//		h: uniform rand [0, 1]
}

// ===============================================
operator distributePoints<<<index>>>(io PoissonDiskData pData, io PoissonDiskDistributor workers[])
{
	Point startPoint = pData.points[index + 1];
	workers[index].run(startPoint);
}

// ===============================================
/// Find wrong points and stores the indices to wrongPointIndices[].
operator findWrongPoints<<<index>>>(io UInt32 wrongPointIndices[], PoissonDiskData pData, UInt32 numPexThreads)
{
	Float32 radius = Float32(sqrt(DIMENSION));
	GridNeighborFinder gnFinder(pData.points, pData.grid);

	UInt32 startIndex;
	UInt32 endIndex;

	if(pData.numPoints < numPexThreads)
	{
		startIndex = 1;
		endIndex = (index == 0)? pData.numPoints + 1 : 0;
	}
	else
	{
		UInt32 mod = pData.numPoints % numPexThreads;
		UInt32 load = (pData.numPoints - mod) / numPexThreads;

		startIndex = load * index + 1;
		endIndex = startIndex + load + 1;
		if(index == numPexThreads - 1)
		{
			endIndex += mod;
		}
	}

	for(Index i = startIndex; i < endIndex; ++i)
	{
		Point point = pData.points[i];
		if(gnFinder.isNeighborExists(point, radius, true))
		{
			AutoLock(pData.lock);
			wrongPointIndices.push(index + 1);
		}
	}
}

function removeWrongPoints(io PoissonDiskData pData, UInt32 wrongPointIndices[])
{
	// Truncate pData.points. Does pData.resize() enough?
	Point newPoints[];
	newPoints.resize(pData.numPoints);
	for(UInt32 i = 0; i < pData.numPoints; ++i)
	{
		newPoints[i] = pData.points[i];
	}
	swap(newPoints, pData.points);

	for(UInt32 i = 0; i < wrongPointIndices.size(); ++i)
	{
		pData.points.swap(i, pData.points.size() - 1);
		pData.points.pop();
	}
}
