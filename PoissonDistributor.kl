require FabricSynchronization;

// [2d/3d]
const UInt32 DIMENSION = 2;

object Counter
{
	UInt32 count;
};

// ===============================================
/// Utility class to find if neighbor points exist
object GridNeighborFinder
{
	/// Shared result points list. For implementation reason points[0] is not used.
	private Point points[];
	/// Shared grid used to distribute points.
	private IGrid grid;
};

function GridNeighborFinder(Point points[], IGrid grid)
{
	this.points = points;
	this.grid = grid;
}

/// Returns true if neighbor is found.
function Boolean GridNeighborFinder.isNeighborExists(Point searchPoint, Float32 radius, Boolean isExcludeSelfCell)
{
	CellCoord cellCoord = this.grid.getCellCoord(searchPoint);

	//  Search neighbor cells to see if no points exists nearby.
	const UInt32 NUM_NEIGHBORS = 25; // [2d/3d] 125 if 3d
	for(UInt32 j = 0; j < NUM_NEIGHBORS; ++j)
	{
		if(isExcludeSelfCell)
		{
			// [2d/3d]
			//if(j == 62)
			if(j == 12)
			{
				continue;
			}
		}
		// [2d/3d]
		//UInt32 k = j / 25 - 2;
		//UInt32 l = (j % 25) / 5 - 2;
		//UInt32 m = j % 5 - 2;
		//CellCoord crd = cellCoord + CellCoord(k, l, m);
		UInt32 k = j / 5 - 2;
		UInt32 l = j % 5 - 2;
		CellCoord crd = cellCoord + CellCoord(k, l);

		if( ! this.grid.isValidCellCoord(crd))
		{
			continue;
		}

		// We could do some more early out check here by looking at the intersection
		// of the cell and the circle/sphere search area.

		UInt32 cellValue = this.grid.getCellValue(crd);

		if(cellValue)
		{
			if((this.points[cellValue] - searchPoint).lengthSquared() < radius * radius)
			{
				// Found a point within radius, reject this point.
				return true;
			}
		}
	}

	return false;
}

// ===============================================
/// Worker class to find points and add them to the result points list.
object CreatePointsWorker
{
	/// Shared result points list. For implementation reason points[0] is not used.
	private Point points[];
	/// Shared region to define where to create points.
	private IRegion region;
	/// Shared grid used to distribute points.
	private IGrid grid;
	/// Shared thread lock.
	private SimpleLock lock;
	private Counter counter;
	/// Per thread actie list.
	private ActiveList activeList;
	/// Per thread random generator.
	private XOrShift randGen;
};

function CreatePointsWorker.initialize!(io UInt32 seed, Point points[], IRegion region, IGrid grid, SimpleLock lock, Counter counter)
{
	this.points = points;
	this.region = region;
	this.grid = grid;
	this.lock = lock;
	this.activeList = ActiveList(seed);
	this.randGen = XOrShift(seed);
	this.counter = counter;	
}

function CreatePointsWorker.run!(Point startPoint)
{
	const UInt32 NUM_ITERATIONS = 30;

	// Running this function in parallel can create wrong points,
	// ie. a point that has neighbor points within the radius.
	// We first ignore them and remove those points later.

	// We chose the grid cell edge length to be the unit of length, ie. 1.0 for efficiency.
	// The disk radius must be sqrt(2.0) and sqrt(3.0) in 2d and 3d cases
	// respectively (See Bridson's paper for more details).
	// Every value which has length unit must be scaled accordingly in advance.

	// NOTE: This is for efficiency (and making the program easier as a hidden purpose).
	// NOTE: I wouldn't do that in a real programming unless critical speed is required
	// NOTE: because it makes debugging and maintenance more difficult.

	Float32 radius = Float32(sqrt(DIMENSION));
	GridNeighborFinder gnFinder(this.points, this.grid);

	this.activeList.push(startPoint);

	Index activeListIndex = 0;
	Point currentPoint = startPoint;

	while(activeListIndex != UInt32Max) // While active list is not empty.
	{
		UInt32 i;
		for(i = 0; i < NUM_ITERATIONS; ++i)
		{
			Point searchPoint = currentPoint + this.uniformAnnulusDistribute(radius);

			if( ! this.region.isInside(searchPoint))
			{
				continue;
			}

			CellCoord cellCoord = this.grid.getCellCoord(searchPoint);

			if( ! gnFinder.isNeighborExists(searchPoint, radius, false))
			{
				Index index = UInt32Max;

				// This lock is used to ensure only one point is created in a single cell,
				// also for array push() which is probably not thread-safe.
				{
					AutoLock(this.lock);
					// Check if no point has been/is being created by another thread.
					if( ! this.grid.getCellValue(cellCoord))
					{
						// We can create a point!
						this.counter.count.atomicInc();
						this.points[this.counter.count] = searchPoint;
						index = this.points.size() - 1;
						this.grid.setCellValue(cellCoord, index);
					}
				}

				if(index != UInt32Max)
				{
					// NOTE: Setting a value to an array element should be thread safe.
					// NOTE: but there may be a slight change it is not, due to bounds
					// NOTE: check or something. I could not find a documentation on it.
					currentPoint = searchPoint;
					this.activeList.push(searchPoint);
					break;
				}

			}
		}

		if(i == NUM_ITERATIONS)
		{
			// Could not create the next point.
			this.activeList.removeElement(activeListIndex);
			currentPoint = this.activeList.getRandom(activeListIndex);
		}
	}
}

private function Point CreatePointsWorker.uniformAnnulusDistribute!(Float32 radius)
{
	// [2d/3d]
	Float32 rnd1 = this.randGen.generate01();
	Float32 rnd2 = this.randGen.generate01();
	Float32 r = radius * sqrt(3 * rnd1 + 1);
	Float32 theta = rnd2 * 3.1415926 * 2;
	return Point(r * cos(theta), r * sin(theta));

	// TODO: 3D case.
	// Inverse function	of c = 1/3*(h^3 + H^2 + h)
	//		c: cumulative distribution function
	//		h: uniform rand [0, 1]
}

// ===============================================
/// Bridson's Poisson disk implementation.
object PoissonDiskDistributor
{
	/// Shared result points list. For implementation reason points[0] is not used.
	Point points[];
	/// Shared grid used to distribute points.
	IGrid grid;
	/// Shared region to define where to create points.
	private IRegion region;
	/// Shared thread lock.
	private SimpleLock lock;

	CreatePointsWorker workers[];
	Counter counter;
};

private function PoissonDiskDistributor.initializePoints!(UInt32 numPexThreads, io UInt32 seed)
{
	const UInt32 NUM_ITERATIONS_PER_THREAD = 5;

	Float32 radius = Float32(sqrt(DIMENSION));
	UInt32 maxNumTries = numPexThreads * NUM_ITERATIONS_PER_THREAD;

	XOrShift randGen(seed);
	Point bBoxMin;
	Point bBoxMax;
	this.region.getBoundingBox(bBoxMin, bBoxMax);

	for(UInt32 i = 0; i < maxNumTries; ++i)
	{
		// [2d/3d]
		//Float32 x = randGen.generate(bBoxMin.x, bBoxMax.x);
		//Float32 y = randGen.generate(bBoxMin.y, bBoxMax.y);
		//Float32 z = randGen.generate(bBoxMin.z, bBoxMax.z);
		//Point point(x, y, z);
		Float32 x = randGen.generate(bBoxMin.x, bBoxMax.x);
		Float32 y = randGen.generate(bBoxMin.y, bBoxMax.y);
		Point point(x, y);

		UInt32 pointsListSize = this.points.size();
		if(this.region.isInside(point))
		{
			UInt32 j;
			for(j = 1; j < pointsListSize; ++j)
			{
				if((point - this.points[j]).lengthSquared() < radius * radius)
				{
					break;
				}
			}

			if(j == pointsListSize)
			{
				++this.counter.count;
				this.points[this.counter.count] = point;
				this.grid.setCellValue(this.grid.getCellCoord(point), this.points.size() - 1);
			}

			if(this.counter.count == numPexThreads)
			{
				return;
			}
		}
	}
}

function PoissonDiskDistributor(UInt32 numPexThreads, IRegion region, io Point points[], Counter counter)
{
	this.points = points;
	this.region = region;
	this.lock = SimpleLock();
	this.counter = counter;

	// Initialize grid.
	Point bBoxMin;
	Point bBoxMax;
	this.region.getBoundingBox(bBoxMin, bBoxMax);

	Float32 EPS = 1.0E-5;

	// [2d/3d]
	//GridSize gridSize(bBoxMax.x - bBoxMin.x + EPS * 2, bBoxMax.y - bBoxMin.y + EPS * 2, bBoxMax.z - bBoxMin.z + EPS * 2);
	//Point origin = bBoxMin - Vec3(EPS, EPS, EPS);
	GridSize gridSize(bBoxMax.x - bBoxMin.x + EPS * 2 + 1, bBoxMax.y - bBoxMin.y + EPS * 2 + 1);
	Point origin = bBoxMin - Vec2(EPS, EPS);

	this.grid = SimpleGrid(gridSize, origin);

	// Initialize workers.
	UInt32 seed = 0;
	for(UInt32 i = 0; i < numPexThreads; ++i)
	{
		CreatePointsWorker worker();
		worker.initialize(seed, this.points, this.region, this.grid, this.lock, this.counter);
		this.workers.push(worker);
	}

	// Create the first points for each thread to start with.
	this.initializePoints(numPexThreads, seed);
}

// ===============================================
operator distributePoints<<<index>>>(io PoissonDiskDistributor distributor)
{
	Point startPoint = distributor.points[index + 1];
	distributor.workers[index].run(startPoint);
}

// ===============================================
/// Find wrong points, do not delete from the points.
operator findWrongPoints<<<index>>>(io UInt32 wrongPointIndices[], Point points[], IGrid grid, UInt32 numPexThreads, SimpleLock lock, UInt32 count)
{
	Float32 radius = Float32(sqrt(DIMENSION));
	UInt32 realSize = count - 1;
	GridNeighborFinder gnFinder(points, grid);

	if(realSize < numPexThreads)
	{
		if(index < realSize)
		{
			if(gnFinder.isNeighborExists(points[index + 1], radius, true))
			{
				AutoLock(lock);
				wrongPointIndices.push(index + 1);
			}
		}

		return;
	}

	UInt32 mod = realSize % numPexThreads;
	UInt32 load = (realSize - mod) / numPexThreads;

	UInt32 startIndex = load * index + 1;
	UInt32 endIndex = startIndex + load + 1;
	if(index == numPexThreads - 1)
	{
		endIndex += mod;
	}

	for(Index i = startIndex; i < endIndex; ++i)
	{
		Point point = points[i];
		if(gnFinder.isNeighborExists(point, radius, true))
		{
			AutoLock(lock);
			wrongPointIndices.push(index + 1);
		}
	}
}
