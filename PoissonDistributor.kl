require Math;
require XOrShift;
require PointDistribute;

// [2d/3d]
const UInt32 DIMENSION = 2;

// ===============================================
/// Utility class to find if neighbor points exist
object GridNeighborFinder
{
	/// Shared result points list. For implementation reason points[0] is not used.
	private Point points[];
	/// Shared grid used to distribute points.
	private IGrid grid;
};

function GridNeighborFinder(Point points[], IGrid grid)
{
	this.points = points;
	this.grid = grid;
}

/// Returns true if neighbor is found.
function Boolean GridNeighborFinder.isNeighborExists(Point searchPoint, Float32 radius, Boolean isExcludeSelfCell)
{
	CellCoord cellCoord = this.grid.getCellCoord(searchPoint);

	//  Search neighbor cells to see if no points exists nearby.
	UInt32 numNeighbors = 25; // [2d/3d] 125 if 3d
	for(UInt32 j = 0; j < numNeighbors; ++j)
	{
		if(isExcludeSelfCell)
		{
			// [2d/3d]
			//if(j == 62)
			if(j == 12)
			{
				continue;
			}
		}
		// [2d/3d]
		//UInt32 k = j / 25 - 2;
		//UInt32 l = (j % 25) / 5 - 2;
		//UInt32 m = j % 5 - 2;
		//CellCoord crd = cellCoord + CellCoord(k, l, m);
		UInt32 k = j / 5 - 2;
		UInt32 l = j % 5 - 2;
		CellCoord crd = cellCoord + CellCoord(k, l);

		if( ! this.grid.isValidCellCoord(crd))
		{
			continue;
		}

		// We could do some more early out check here by looking at the intersection
		// of the cell and the circle/sphere search area.

		UInt32 cellValue = this.grid.getCellValue(crd);

		if(cellValue)
		{
			if((this.points[cellValue] - searchPoint).lengthSquared() < radius * radius)
			{
				// Found a point within radius, reject this point.
				return true;
			}
		}
	}

	return false;
}

// ===============================================
/// Worker class to find points and add them to the result points list.
object CreatePointsWorker
{
	/// Shared result points list. For implementation reason points[0] is not used.
	private Point points[];
	/// Shared region to define where to create points.
	private IRegion region;
	/// Shared grid used to distribute points.
	private IGrid grid;
	/// Shared thread lock.
	private SimpleLock lock;
	/// Per thread actie list.
	private ActiveList activeList;
	/// Per thread random generator.
	private XOrShift randGen;
};

function CreatePointsWorker.initialize!(io UInt32 seed, Point points[], IRegion region, IGrid grid, SimpleLock lock)
{
	this.points = points;
	this.region = region;
	this.grid = grid;
	this.lock = lock;
	this.activeList = ActiveList(seed);
	this.randGen = XOrShift(seed);
}

function CreatePointsWorker.run!(Point startPoint)
{
	const UInt32 NUM_ITERATIONS = 30;

	// Running this function in parallel can create wrong points,
	// ie. a point that has neighbor points within the radius.
	// We first ignore them and remove those points later.

	// We chose the grid cell edge length to be the unit of length, ie. 1.0 for efficiency.
	// The disk radius must be sqrt(2.0) and sqrt(3.0) in 2d and 3d cases
	// respectively (See Bridson's paper for more details).
	// Every value which has length unit must be scaled accordingly in advance.

	// NOTE: This is for efficiency (and making the program easier as a hidden purpose).
	// NOTE: I wouldn't do that in a real programming unless critical speed is required
	// NOTE: because it makes debugging and maintenance more difficult.

	Float32 radius = Float32(sqrt(DIMENSION));
	GridNeighborFinder gnFinder(this.points, this.grid);

	this.activeList.push(startPoint);

	Index activeListIndex = 0;
	Point currentPoint = startPoint;

	while(activeListIndex != UInt32Max) // While active list is not empty.
	{
		UInt32 i;
		for(i = 0; i < NUM_ITERATIONS; ++i)
		{
			Point searchPoint = currentPoint + this.uniformAnnulusDistribute(radius);

			if( ! this.region.isInside(searchPoint))
			{
				continue;
			}

			CellCoord cellCoord = this.grid.getCellCoord(searchPoint);

			if( ! gnFinder.isNeighborExists(searchPoint, radius, false))
			{
				Index index = UInt32Max;

				// This lock is used to ensure only one point is created in a single cell,
				// also for array push() which is probably not thread-safe.
				{
					AutoLock(this.lock);
					// Check if no point has been/is being created by another thread.
					if( ! this.grid.getCellValue(cellCoord))
					{
						// We can create a point!
						this.points.push(searchPoint);
						index = this.points.size() - 1;
						this.grid.setCellValue(cellCoord, index);
					}
				}

				if(index != UInt32Max)
				{
					// NOTE: Setting a value to an array element should be thread safe.
					// NOTE: but there may be a slight change it is not, due to bounds
					// NOTE: check or something. I could not find a documentation on it.
					currentPoint = searchPoint;
					this.activeList.push(searchPoint);
					break;
				}

			}
		}

		if(i == NUM_ITERATIONS)
		{
			// Could not create the next point.
			this.activeList.removeElement(activeListIndex);
			currentPoint = this.activeList.getRandom(activeListIndex);
		}
	}
}

private function Point CreatePointsWorker.uniformAnnulusDistribute!(Float32 radius)
{
	// [2d/3d]
	Float32 rnd1 = this.randGen.generate01();
	Float32 rnd2 = this.randGen.generate01();
	Float32 r = radius * sqrt(3 * rnd1 + 1);
	Float32 theta = rnd2 * 3.1415926 * 2;
	return Point(r * cos(theta), r * sin(theta));

	// TODO: 3D case.
	// Inverse function	of c = 1/3*(h^3 + H^2 + h)
	//		c: cumulative distribution function
	//		h: uniform rand [0, 1]
}

// ===============================================
/// Bridson's Poisson disk implementation.
object PoissonDiskDistributor
{
	/// Shared result points list. For implementation reason points[0] is not used.
	Point points[];
	/// Shared grid used to distribute points.
	IGrid grid;
	/// Shared region to define where to create points.
	private IRegion region;
	/// Shared thread lock.
	private SimpleLock lock;

	CreatePointsWorker workers[];
};

private function PoissonDiskDistributor.initializePoints!(UInt32 numPexThreads, io UInt32 seed)
{
	Float32 radius = Float32(sqrt(DIMENSION));
	UInt32 maxNumTries = numPexThreads * 5;

	XOrShift randGen(seed);
	Point bBoxMin;
	Point bBoxMax;
	this.region.getBoundingBox(bBoxMin, bBoxMax);

	for(UInt32 i = 0; i < maxNumTries; ++i)
	{
		// [2d/3d]
		//Float32 x = randGen.generate(bBoxMin.x, bBoxMax.x);
		//Float32 y = randGen.generate(bBoxMin.y, bBoxMax.y);
		//Float32 z = randGen.generate(bBoxMin.z, bBoxMax.z);
		//Point point(x, y, z);
		Float32 x = randGen.generate(bBoxMin.x, bBoxMax.x);
		Float32 y = randGen.generate(bBoxMin.y, bBoxMax.y);
		Point point(x, y);

		UInt32 pointsListSize = this.points.size();
		if(this.region.isInside(point))
		{
			UInt32 j;
			for(j = 1; j < pointsListSize; ++j)
			{
				if((point - this.points[j]).lengthSquared() < radius * radius)
				{
					break;
				}
			}

			if(j == pointsListSize)
			{
				this.points.push(point);
				this.grid.setCellValue(this.grid.getCellCoord(point), this.points.size() - 1);
			}

			if(this.points.size() == numPexThreads + 1)
			{
				return;
			}
		}
	}
}

function PoissonDiskDistributor(UInt32 numPexThreads, IRegion region, io Point points[])
{
	this.points = points;
	this.region = region;
	this.lock = SimpleLock();

	points.resize(1); // Add dummy.

	// Initialize grid.
	Point bBoxMin;
	Point bBoxMax;
	this.region.getBoundingBox(bBoxMin, bBoxMax);

	Float32 EPS = 1.0E-5;

	// [2d/3d]
	//GridSize gridSize(bBoxMax.x - bBoxMin.x + EPS * 2, bBoxMax.y - bBoxMin.y + EPS * 2, bBoxMax.z - bBoxMin.z + EPS * 2);
	//Point origin = bBoxMin - Vec3(EPS, EPS, EPS);
	GridSize gridSize(bBoxMax.x - bBoxMin.x + EPS * 2 + 1, bBoxMax.y - bBoxMin.y + EPS * 2 + 1);
	Point origin = bBoxMin - Vec2(EPS, EPS);

	this.grid = SimpleGrid(gridSize, origin);

	// Initialize workers.
	UInt32 seed = 0;
	for(UInt32 i = 0; i < numPexThreads; ++i)
	{
		CreatePointsWorker worker();
		worker.initialize(seed, this.points, this.region, this.grid, this.lock);
		this.workers.push(worker);
	}

	// Create the first points for each thread to start with.
	this.initializePoints(numPexThreads, seed);
}

// ===============================================
operator distributePoints<<<index>>>(io PoissonDiskDistributor distributor)
{
	Point startPoint = distributor.points[index + 1];
	distributor.workers[index].run(startPoint);
}

// ===============================================
/// Find wrong points, do not delete from the points.
operator findWrongPoints<<<index>>>(io UInt32 wrongPointIndices[], Point points[], IGrid grid, UInt32 numPexThreads, SimpleLock lock)
{
	Float32 radius = Float32(sqrt(DIMENSION));
	UInt32 realSize = points.size() - 1;
	GridNeighborFinder gnFinder(points, grid);

	if(realSize < numPexThreads)
	{
		if(index < realSize)
		{
			if(gnFinder.isNeighborExists(points[index + 1], radius, true))
			{
				AutoLock(lock);
				wrongPointIndices.push(index + 1);
			}
		}

		return;
	}

	UInt32 mod = realSize % numPexThreads;
	UInt32 load = (realSize - mod) / numPexThreads;

	UInt32 startIndex = load * index + 1;
	UInt32 endIndex = startIndex + load + 1;
	if(index == numPexThreads - 1)
	{
		endIndex += mod;
	}

	for(Index i = startIndex; i < endIndex; ++i)
	{
		Point point = points[i];
		if(gnFinder.isNeighborExists(point, radius, true))
		{
			AutoLock(lock);
			wrongPointIndices.push(index + 1);
		}
	}
}

operator entry() {
	SimpleRectRegion region(Point(-20.6, -30.4), Point(50.0, 10.0));
	Point points[];

	UInt32 numPexThreads = getThreadCount();
	PoissonDiskDistributor distributor(numPexThreads, region, points);

	numPexThreads = Math_min(numPexThreads, points.size() - 1);
	distributePoints<<<numPexThreads>>>(distributor);

	// UInt32 wrongPointIndices[];
	// SimpleLock lock();
	// findWrongPoints<<<numPexThreads>>>(wrongPointIndices, points, distributor.grid, numPexThreads, lock);

	// report("wrong " + wrongPointIndices.size());

	// Display result.
	Point bBoxMin, bBoxMax;
	region.getBoundingBox(bBoxMin, bBoxMax);
	report("minx, miny, maxx, maxy = " + bBoxMin.x + ", " + bBoxMin.y + ", " + bBoxMax.x + ", " + bBoxMax.y);
	report("p = []");
	for(UInt32 i = 1; i < points.size(); ++i)
	{
		Float32 x = points[i].x;
		Float32 y = points[i].y;
		//report("p.append((" + x + ", " + y + "))");
	}
	report(points.size() - 1);
}

