require PointDistribute;

operator entry() {

	// Region to sprinkle points.
	SimpleRectRegion region(Point(0.0, 0.0), Point(10.0, 10.0));

	// Result array.
	Point points[];
	points.resize(65536);

	// Distribute.

	UInt32 seed = 0;
	UInt32 numPexThreads = getThreadCount();
	//UInt32 numPexThreads = 1;
	PoissonDiskData pData(numPexThreads, points, region, seed);
	numPexThreads = Math_min(numPexThreads, pData.numPoints);

	PoissonDiskDistributor distributors[];
	for(UInt32 i = 0; i < numPexThreads; ++i)
	{
		distributors.push(PoissonDiskDistributor(seed, pData));
	}
	distributePoints<<<numPexThreads>>>(pData, distributors);

	// Assumed resize doesn't change [0..numPoints) data.
	points.resize(pData.numPoints);

	report("# points: " + pData.numPoints);

	// Find very small number of wrong points due to multi-threading.

	UInt32 wrongPointIndices[];
	wrongPointIndices.resize(pData.numPoints);
	SimpleLock lock();
	findWrongPoints<<<pData.numPoints>>>(wrongPointIndices, pData);

	// Remove them in single thread.
	removeWrongPoints(pData, wrongPointIndices);

	// Display result.
	Point bBoxMin, bBoxMax;
	region.getBoundingBox(bBoxMin, bBoxMax);
	report("minx, miny, maxx, maxy = " + bBoxMin.x + ", " + bBoxMin.y + ", " + bBoxMax.x + ", " + bBoxMax.y);
	report("p = []");
	for(UInt32 i = 0; i < pData.numPoints; ++i)
	{
		Float32 x = points[i].x;
		Float32 y = points[i].y;
		report("p.append((" + x + ", " + y + "))");
	}
	report(pData.numPoints);
}

